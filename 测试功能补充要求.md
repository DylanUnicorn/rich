# 测试要求

## 指令列表

### dump

`dump` 无参数

导出内容：

见存档格式

`dump` 指令只能在游戏进行时使用，导出游戏状态并**立刻结束游戏**（测试时候使用）

### step

`step` `<n>`

n 可以为**任意大**的正整数。（测试时候使用）

### quit

退出游戏，结束进程。（游戏时候使用）

## 名词查询列表

- 玩家代号
  
  - Q, A, S, J
  
  - Q=1, A=2, S=3, J=4

## 输入输出举例

测试用例下没有preset.json时，输入input.txt

```txt
10000
421
dump
```

则 dump.json

```JSON
{    "players": [        {            "index": 0,          // 玩家顺序，从 0 开始            "name": "J",           // 角色代号，单个字符（Q, A，S，J）            "fund": int,           // 资金            "credit": int,         // 点数            "location": int,       // 当前位置，从起始点开始顺时针，从 0 开始            "alive": bool,         // 玩家是否存活            "prop": {                "bomb": int,       // 玩家拥有炸弹个数                "barrier": int,    // 玩家拥有路障个数                "robot": int,      // 玩家拥有机器人个数                "total": int       // 玩家拥有道具总计个数            },            "buff":{                "god": int,        // 财神附体剩余回合数，没有则为 0                "prison": int,     // 蹲监狱剩余回合数，没有则为 0                "hospital": int    // 住院剩余回合数，没有则为 0            }        },        {            "index": 1,          // 玩家顺序，从 0 开始            "name": "A",           // 角色代号，单个字符（Q, A，S，J）            "fund": int,           // 资金            "credit": int,         // 点数            "location": int,       // 当前位置，从起始点开始顺时针，从 0 开始            "alive": bool,         // 玩家是否存活            "prop": {                "bomb": int,       // 玩家拥有炸弹个数                "barrier": int,    // 玩家拥有路障个数                "robot": int,      // 玩家拥有机器人个数                "total": int       // 玩家拥有道具总计个数            },            "buff":{                "god": int,        // 财神附体剩余回合数，没有则为 0                "prison": int,     // 蹲监狱剩余回合数，没有则为 0                "hospital": int    // 住院剩余回合数，没有则为 0            }        },        {            "index": 2,          // 玩家顺序，从 0 开始            "name": "Q",           // 角色代号，单个字符（Q, A，S，J）            "fund": int,           // 资金            "credit": int,         // 点数            "location": int,       // 当前位置，从起始点开始顺时针，从 0 开始            "alive": bool,         // 玩家是否存活            "prop": {                "bomb": int,       // 玩家拥有炸弹个数                "barrier": int,    // 玩家拥有路障个数                "robot": int,      // 玩家拥有机器人个数                "total": int       // 玩家拥有道具总计个数            },            "buff":{                "god": int,        // 财神附体剩余回合数，没有则为 0                "prison": int,     // 蹲监狱剩余回合数，没有则为 0                "hospital": int    // 住院剩余回合数，没有则为 0            }        }    ],    "houses": {                    // 房产属性        "1": {                     // 房产位置，数字文本，（一维坐标）            "owner": "name",       // 所有者            "level": int,          // 等级（0-3）        },        "3": {            "owner":"name",            "level":int,        },        "其他位置房产": {...},        ...    },    "placed_prop":{        "bomb": [int, ...],        // 炸弹位置，数组，每个元素表示一个炸弹的位置（一维坐标）        "barrier": [int, ...]      // 路障位置，数组，每个元素表示一个路障的位置（一维坐标）    },    "game": {        "now_player": int,         // 当前操作玩家        "next_player": int,        // 下一操作玩家        "ended": bool,             // 游戏是否结束        "winner": int,             // 胜者 ID，未结束为 -1    },}
```

其他未输入的可以以某种方式进行默认数据填充

然后`expected_result.json`

```JSON
{    "players": [        {            "index": 0,          // 玩家顺序，从 0 开始            "name": "J",           // 角色代号，单个字符（Q, A，S，J）            "fund": int,           // 资金            "credit": int,         // 点数            "location": int,       // 当前位置，从起始点开始顺时针，从 0 开始            "alive": bool,         // 玩家是否存活            "prop": {                "bomb": int,       // 玩家拥有炸弹个数                "barrier": int,    // 玩家拥有路障个数                "robot": int,      // 玩家拥有机器人个数                "total": int       // 玩家拥有道具总计个数            },            "buff":{                "god": int,        // 财神附体剩余回合数，没有则为 0                "prison": int,     // 蹲监狱剩余回合数，没有则为 0                "hospital": int    // 住院剩余回合数，没有则为 0            }        },        {            "index": 1,          // 玩家顺序，从 0 开始            "name": "A",           // 角色代号，单个字符（Q, A，S，J）            "fund": int,           // 资金            "credit": int,         // 点数            "location": int,       // 当前位置，从起始点开始顺时针，从 0 开始            "alive": bool,         // 玩家是否存活            "prop": {                "bomb": int,       // 玩家拥有炸弹个数                "barrier": int,    // 玩家拥有路障个数                "robot": int,      // 玩家拥有机器人个数                "total": int       // 玩家拥有道具总计个数            },            "buff":{                "god": int,        // 财神附体剩余回合数，没有则为 0                "prison": int,     // 蹲监狱剩余回合数，没有则为 0                "hospital": int    // 住院剩余回合数，没有则为 0            }        },        {            "index": 2,          // 玩家顺序，从 0 开始            "name": "Q",           // 角色代号，单个字符（Q, A，S，J）            "fund": int,           // 资金            "credit": int,         // 点数            "location": int,       // 当前位置，从起始点开始顺时针，从 0 开始            "alive": bool,         // 玩家是否存活            "prop": {                "bomb": int,       // 玩家拥有炸弹个数                "barrier": int,    // 玩家拥有路障个数                "robot": int,      // 玩家拥有机器人个数                "total": int       // 玩家拥有道具总计个数            },            "buff":{                "god": int,        // 财神附体剩余回合数，没有则为 0                "prison": int,     // 蹲监狱剩余回合数，没有则为 0                "hospital": int    // 住院剩余回合数，没有则为 0            }        }    ],    "houses": {                    // 房产属性        "1": {                     // 房产位置，数字文本，（一维坐标）            "owner": "name",       // 所有者            "level": int,          // 等级（0-3）        },        "3": {            "owner":"name",            "level":int,        },        "其他位置房产": {...},        ...    },    "placed_prop":{        "bomb": [int, ...],        // 炸弹位置，数组，每个元素表示一个炸弹的位置（一维坐标）        "barrier": [int, ...]      // 路障位置，数组，每个元素表示一个路障的位置（一维坐标）    },    "game": {        "now_player": int,         // 当前操作玩家        "next_player": int,        // 下一操作玩家        "ended": bool,             // 游戏是否结束        "winner": int,             // 胜者 ID，未结束为 -1    },}
```

expected_result.json也将以相同的某种方式进行填充，然后将`dump.json`与`expected_result.json`进行匹配 。

## 标准输出

标准输出为用户界面，无需测试。

## 命令格式

`./RichGame <``test_case_dir``>`

## 存档格式

通过参数输入初始存档与文件输出。

```JSON
{    "players": [        {            "index": int,          // 玩家顺序，从 0 开始            "name": str,           // 角色代号，单个字符（Q, A，S，J）            "fund": int,           // 资金            "credit": int,         // 点数            "location": int,       // 当前位置，从起始点开始顺时针，从 0 开始            "alive": bool,         // 玩家是否存活            "prop": {                "bomb": int,       // 玩家拥有炸弹个数                "barrier": int,    // 玩家拥有路障个数                "robot": int,      // 玩家拥有机器人个数                "total": int       // 玩家拥有道具总计个数            },            "buff":{                "god": int,        // 财神附体剩余回合数，没有则为 0                "prison": int,     // 蹲监狱剩余回合数，没有则为 0                "hospital": int    // 住院剩余回合数，没有则为 0            }        },        ...    ],    "houses": {                    // 房产属性        "1": {                     // 房产位置，数字文本，（一维坐标）            "owner": "name",       // 所有者            "level": int,          // 等级（0-3）        },        "3": {            "owner":"name",            "level":int,        },        "其他位置房产": {...},        ...    },    "placed_prop":{        "bomb": [int, ...],        // 炸弹位置，数组，每个元素表示一个炸弹的位置（一维坐标）        "barrier": [int, ...]      // 路障位置，数组，每个元素表示一个路障的位置（一维坐标）    },    "game": {        "now_player": int,         // 当前操作玩家        "next_player": int,        // 下一操作玩家        "ended": bool,             // 游戏是否结束        "winner": int,             // 胜者 ID，未结束为 -1    },}
```

作为初始值输入时，除了 `game.now_player`，忽略`game` 下其他

## 测试模式

1. 启动时附加命令行参数进入测试模式
   
     `./rich <test_case_dir>`
   
   1. 其中test_case_dir是我们的文件夹，里面有expected_result.json（基于我们对游戏的设计自己写的一个预期输出），input.txt（程序运行之后作为标准输入，代替人工手动输入），preset.json是我们的一个预设参数，完成了对游戏的初始化（注意preset.json和expected_result.json都是按照存档格式里面的模板来进行的数据填充以及比对）
   
   2. 程序运行的时候使用preset.json完成游戏初始化的配置

   3. input.txt中，一行放一个输入，适应了我们人为的输入。（当然我们人为输入是允许放一些奇怪的文字的，这时候系统就会提示不存在的指令不过我们测试无需关心），输入可以是系统要求做的输入（比如是否买房， 花费点数之类等等），也可以是游戏输入（比如说掷骰子，放路障，遥控骰子等等）。
   
   4. 假如输入的test_case_dir文件夹里面没有preset.json的时候，可以手动设置初始资金和选择角色的设置，其他的可以设置成某一个默认值（主要是用来测试设置资金和选角的功能）
   
   5. 假如输入的test_case_dir文件夹里面有preset.json，直接根据preset.json去设置人物，地图，资金，道具，点数等等属性，跳过初始资金选择，初始选角。
   
   6. player.index对应玩家的游玩顺序（按输入顺序为0,1,2,3）先输入的index在前，根据`名词查询列表`，假如我输入32，那么S的index就是0，A的index就是1.

2. `dump` `step n` 指令只能在测试模式中使用。
   
   1. dump指令会导出所有状态成为dump.json（同样是基于存档格式里面的json模板），路径和expected_result.json和preset.json在同一个路径下面，然后游戏**立刻结束**，接下来就对dump.json和expected_result.json进行关键数据的比对，假如比对通过，则该测试样例通过，有报文输出。

3. 测试用例通过标准输入控制程序，通过标准输出读出结果。
   
   1. 可以通过python进行标准输入input.txt的读取，json文件的管理以及比对，测试例程的管理以及输出，当然也可以配合bash脚本，怎么方便怎么来，最后只要求通过一行命令完整整个测试流程，然后跑完所有测试例程告诉我哪一些没通过，哪一些通过，通过了多少，没通过多少。
   2. 可以基于多线程同时跑多个测试例程
   3. 不出意外的话，所有的测试例程都在tests文件夹里面，每个测试例程都是一个子文件夹

4. 没有参数（`test_case_dir`）就是正常游戏模式
